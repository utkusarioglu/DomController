import { t_ri0 } from "@utkusarioglu/resolver";
import { SeparatorHandler } from "../Common/separator_handler";
import { t_resolutionInstructionNoArgs } from "@utkusarioglu/resolver";
import { t_scope, t_singleScope, t_waitSet, t_transmission, e_ServiceGroup, i_staticContentArchive, t_localControllerStack, t_epoch, i_talk, i_Request, i_Response } from "../Common/t_controller";
import { t_namespace } from "@utkusarioglu/namespace";
export declare class Controller extends SeparatorHandler {
    private static _event_emitter_class;
    private static _global_controller;
    private static _local_controllers;
    private static _global_namespaces;
    private _controller_global_namespace;
    private _controller_local_namespace;
    private static _static_content_archive;
    private static _static_responders;
    private static _forced_dynamic_service;
    constructor(namespace: t_namespace);
    static flush_GlobalController(): void;
    private set_GlobalController;
    static set_EventEmitter(event_emitter: Object): void;
    static get_EventEmitter(): Object;
    get_EventEmitter(): any;
    request<T>(responding_namespace: t_namespace, talk: t_ri0, scope?: t_singleScope, group?: e_ServiceGroup): Promise<i_Response<T>>;
    private request_DynamicTransmission;
    respond(response_func: (transmission: i_Request) => Promise<any>, is_static?: boolean, scope?: t_scope, group?: e_ServiceGroup): this;
    get_DialogueArchive(scope: t_singleScope): object;
    private static set_PromisifiedStaticContent;
    static get_AllStaticChannels(): t_namespace[];
    static get_AllStaticContent(): i_staticContentArchive;
    static flush_StaticContentArchive(): void;
    static force_AllDynamicService(): void;
    announce(recipient_namespace: t_namespace, talk: t_ri0, scope?: t_scope, delay?: boolean | t_epoch): this;
    private static is_StaticResponder;
    get_AnnouncementArchive(scope: t_singleScope): object[];
    subscribe(listen: t_resolutionInstructionNoArgs, callback: (transmission: i_talk<any>) => void, subcribed_namespace?: t_namespace, scope?: t_scope): this;
    wait(recipient_namespace: t_namespace, listen: t_resolutionInstructionNoArgs, test_callback?: (transmission: t_transmission) => boolean, action_callback?: (transmission: t_transmission) => void, scope?: t_singleScope, count?: number, current_count?: number): Promise<any>;
    wait_Some(wait_set: t_waitSet[], scope: t_singleScope): Promise<any>;
    set_LocalNamespace(local_namespace: t_namespace): this;
    get_LocalNamespace(): t_namespace;
    get_LocalNamespaces(): t_namespace[];
    set_GlobalNamespace(global_namespace: t_namespace): this;
    get_GlobalNamespace(): t_namespace;
    private create_LocalNamespace;
    private destroy_LocalNamespace;
    private add_Controller_ToGlobalNamespaces;
    static get_GlobalNamespaces(): t_namespace[];
    private static flush_GlobalNamespaces;
    private get_Scopes;
    static get_LocalControllerStack(): t_localControllerStack;
}
